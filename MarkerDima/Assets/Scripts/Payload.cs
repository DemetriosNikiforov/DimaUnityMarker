using UnityEditor;
using UnityEditor.Experimental.GraphView;
using UnityEngine;
using UnityEngine.UIElements;

public class Payload : MonoBehaviour, IMarkerUPNP
{
    [Header("Угол поворота башни:")]
    [SerializeField]
    private float rotationAngleY = 30f;
    [Header("Минимальный угол поворота ракетницы:")]
    [SerializeField]
    private float minRotationAngleX = -10f;
    [Header("Максимальный угол поворота ракетницы:")]
    [SerializeField]
    private float maxRotationAngleX = 30f;

    [Space]

    [Header("Скорость поворота башни по оси Y:")]
    [SerializeField]
    private float speedRotationY = 0.1f;
    [Header("скорость поворота ракетницы по оси X:")]
    [SerializeField]
    private float speedRotationX = 0.1f;

    [Space]

    [Header("Обьект полезной нагрузки для поворота по сои Y:")]
    [SerializeField]
    private Transform playloadRotationY;

    [Header("Обьект полезной нагрузки для поворота по сои X:")]
    [SerializeField]
    private Transform playloadRotationX;

    [Space]

    [Header("Вес полезной нагрузки:")]
    [SerializeField]
    private float weight = 0f;
    [Header("Физика маркера:")]
    [SerializeField]
    private Rigidbody rb;

    float IMarkerUPNP.Weight
    {
        get { return weight; }
        set
        {
            weight = value;
        }
    }



    // Start is called before the first frame update
    void Awake()
    {
        Init();
    }

    void Update()
    {
        if (Input.GetMouseButton(0))
        {
            RotatePlayloadY();
            RotatePlayloadX();
        }
    }
    #region Interface methods
    public void Init()
    {
        rb.mass += weight;
    }

    public void EnableUPNP()
    {

    }

    public void DisavleUPNP()
    {

    }
    #endregion

    #region Additional methods

    /// <summary>
    /// Поворачивает элемент полезной нагрузки по оси Y
    /// </summary>
    private void RotatePlayloadY()
    {
        playloadRotationY.localEulerAngles += Vector3.up * Input.GetAxis("Mouse X") * speedRotationY * Time.deltaTime;
        playloadRotationY.localEulerAngles = Vector3.up * ClampAngle(playloadRotationY.localEulerAngles.y, -rotationAngleY, rotationAngleY);
    }

    /// <summary>
    /// Поворачивает элемент полезной нагрузки по оси X
    /// </summary>
    private void RotatePlayloadX()
    {
        playloadRotationX.localEulerAngles += -1 * Vector3.right * Input.GetAxis("Mouse Y") * speedRotationX * Time.deltaTime;
        playloadRotationX.localEulerAngles = Vector3.right * ClampAngle(playloadRotationX.localEulerAngles.x, minRotationAngleX, maxRotationAngleX);

    }

    /// <summary>
    /// Функция ограничения диапазона угла
    /// </summary>
    /// <param name="value">Тукущее значение угла</param>
    /// <param name="min">Минимальное значение угла</param>
    /// <param name="max">Максимальное значение угла</param>
    /// <returns>Возращает угол из диапазона</returns>
    private float ClampAngle(float value, float min, float max)
    {
        if (value > 180)
        {
            value -= 360;
        }

        if (value < min)
        {
            return min;
        }
        else if (value > max)
        {
            return max;
        }
        return value;
    }

    #endregion


}






